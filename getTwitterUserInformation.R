getTwitterUserInformation<-function(idVector, oauth_consumer_key, oauth_consumer_secret, oauth_access_token, oauth_access_token_secret, verbose=F)
{

  require(Hmisc)
require(twitteR)

  #connect to API
setup_twitter_oauth(oauth_consumer_key, oauth_consumer_secret, oauth_access_token, oauth_access_token_secret)
  
  
#API only allows batches of 100, so we have to break up our idVector in pieces =< 100 unique values
unique_ids<-unique(idVector)
user.information<-data.frame()
  batches<-ceil(length(unique_ids)/99)
  user.information<-data.frame()
  for (x in 1:batches)
  {
    if(isTRUE(verbose))
    {
      print (paste("Working on batch", x, "out of ", batches))
    }
    #ids to query
    start<-((x-1)*99)+1
    stop<-ifelse(x*99 > length(unique_ids), length(unique_ids), x*99)
    ids<-unique_ids[start:stop]
    
   users<- lookupUsers(ids)
   
  
    data.rows<-do.call(rbind, lapply(users, as.data.frame))
    rbind(data.rows, user.information)->user.information
     
   
    
  }

  return(user.information)
  
}

#Function that takes a vector of tweet ids and pulls the full status records for these ids, providing access to the screenName of the user
tweetIdsToUser<-function(idVector, oauth_consumer_key, oauth_consumer_secret, oauth_access_token=NULL, oauth_access_token_secret=NULL, verbose=F)
{
  require(Hmisc)
  require(twitteR)
  
  #connect to API
  setup_twitter_oauth(oauth_consumer_key, oauth_consumer_secret, oauth_access_token, oauth_access_token_secret)
  
  
  #API only allows batches of 100, so we have to break up our idVector in pieces =< 100 unique values
  unique_ids<-unique(idVector)
  status.information<-data.frame()
  batches<-ceil(length(unique_ids)/100)

  for (x in 1:batches)
  {
    if(isTRUE(verbose))
    {
      print (paste("Working on batch", x, "out of ", batches))
    }
    #ids to query
    start<-((x-1)*100)+1
    stop<-ifelse(x*100 > length(unique_ids), length(unique_ids), x*100)
    ids<-unique_ids[start:stop]
    tryCatch({
      status<- lookup_statuses(as.character(ids))
    }, warning=function(x){print(x)},
    error=function(x){print(x)},
    finally={  
      status<- lookup_statuses(as.character(ids))
    })
    
    
  statuses<-do.call(rbind, lapply(status, as.data.frame))
      rbind(statuses, status.information)->status.information
    
    
  }
  
  return(status.information)
  
  
}

#function to combine the dataframes generated by the earlier two functions with the original dataframe, so you can go from tweet ID to user information. To used in conjunction with sapply()
addUserMetaData<-function(tweetId, status_database, user_database, meta_data=c("location", "id", "name", "lang", "screenName"))
{
  require(Hmisc)
  
  if(meta_data %nin% c("location", "id", "name", "lang", "screenName"))
  {
    stop("Argument 'meta_data' must be one of: location, id, name, lang, screenName")
    
  }
  else
  {
    if(any(which(status_database[,"id"]==as.character(trimws(tweetId))))) 
    {
      screenName<-as.character(status_database[which(status_database[,"id"]==as.character(trimws(tweetId)))[1], "screenName"])
      if(any(which(user_database[,"screenName"]==as.character(trimws(screenName))))) 
      {
        return( as.character(user_database[which(user_database[,"screenName"]==as.character(trimws(screenName)))[1], meta_data]))
      }
      else
      {
        return(NA)
      }
      
    }
    else
    {
      return(NA)
    }
    
  }
}


estimateGender<-function(first.names, verbose=F)
{
  require(Hmisc)
  require(gender)
  require(genderdata)
  
 gender<-data.frame()
  batches<-ceil(length(first.names)/9)
  
  for (x in 1:batches)
  {
    if(isTRUE(verbose))
    {
      print (paste("Working on batch", x, "out of ", batches))
    }
    #ids to query
    start<-((x-1)*9)+1
    stop<-ifelse(x*9 > length(first.names), length(first.names), x*9)
  gender.batch<-gender(as.character(first.names[start:stop]), method="genderize")
  rbind(gender, gender.batch)->gender
  }
  return(gender)
}





  
